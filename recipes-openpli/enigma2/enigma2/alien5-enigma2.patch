diff -Naur enigma2-PLi/configure.ac enigma2-PersianPrince/configure.ac
--- enigma2-PLi/configure.ac	2018-08-04 13:20:23.000000000 +0430
+++ enigma2-PersianPrince/configure.ac	2018-08-06 10:51:45.469511389 +0430
@@ -198,6 +198,10 @@
 	PKG_CHECK_MODULES(DVBCSA, libdvbcsa)
 fi
 
+if test "$BOXTYPE" == "alien5" -o "$BOXTYPE" == "k1pro" -o "$BOXTYPE" == "k2pro" -o "$BOXTYPE" == "k2prov2" -o "$BOXTYPE" == "k3pro" -o "$BOXTYPE" == "k1plus"; then
+	AC_DEFINE(HAVE_ALIEN5, 1,[Enable Alien 5 family related changes])
+fi
+
 AC_ARG_WITH(alphablendingacceleration,
 	AC_HELP_STRING([--with-alphablendingacceleration=never/always/auto], [alphablending acceleration strategy: never accelerate / always accelerate / automatically decide when to accelerate (default)]),
 	[[with_alphablendingacceleration=$withval]],
diff -Naur enigma2-PLi/lib/dvb/amldecoder.cpp enigma2-PersianPrince/lib/dvb/amldecoder.cpp
--- enigma2-PLi/lib/dvb/amldecoder.cpp	2018-08-04 13:20:23.000000000 +0430
+++ enigma2-PersianPrince/lib/dvb/amldecoder.cpp	2018-08-06 11:31:54.816564115 +0430
@@ -222,8 +222,19 @@
 				m_codec.video_type = VFORMAT_MPEG4; //maybe?
 				t = "MPEG4 Part2";
 				break;
+#if defined(__aarch64__)
+			case H265_HEVC:
+				m_codec.video_type = VFORMAT_HEVC; //maybe?
+				t = "H265 HEVC";
+				break;
+#endif
 		}
 		eDebug("[eAMLTSMPEGDecoder::setVideoPID] vpid=%d, type=%d %s", vpid, type, t.c_str());
+		
+#if HAVE_ALIEN5
+
+		aml_change_vpid(vpid, m_codec.video_type);
+#endif
 	}
 	return 0;
 }
@@ -249,6 +260,10 @@
 				m_codec.audio_type = AFORMAT_AC3;
 				t = "AC3";
 				break;
+			case aDDP:
+				m_codec.audio_type = AFORMAT_AC3;
+				t = "AC3";
+				break;
 			case aAAC:
 				m_codec.audio_type = AFORMAT_AAC;
 				t = "AAC";
diff -Naur enigma2-PLi/lib/dvb/amldecoder.h enigma2-PersianPrince/lib/dvb/amldecoder.h
--- enigma2-PLi/lib/dvb/amldecoder.h	2018-08-04 13:20:23.000000000 +0430
+++ enigma2-PersianPrince/lib/dvb/amldecoder.h	2018-08-06 11:46:44.329339696 +0430
@@ -89,7 +89,7 @@
 	void *adec_handle;
 
 public:
-	enum { aMPEG, aAC3, aDTS, aAAC, aAACHE, aLPCM, aDTSHD, aDDP, MPEG2 = 0, MPEG4_H264, MPEG1, MPEG4_Part2, VC1, VC1_SM };
+	enum { aMPEG, aAC3, aDTS, aAAC, aAACHE, aLPCM, aDTSHD, aDDP, MPEG2 = 0, MPEG4_H264, MPEG1, MPEG4_Part2, VC1, VC1_SM, H265_HEVC };
 	enum { pidNone = -1 };
 	eAMLTSMPEGDecoder(eDVBDemux *demux, int decoder);
 	virtual ~eAMLTSMPEGDecoder();
diff -Naur enigma2-PLi/lib/dvb/frontend.cpp enigma2-PersianPrince/lib/dvb/frontend.cpp
--- enigma2-PLi/lib/dvb/frontend.cpp	2018-08-04 13:20:23.000000000 +0430
+++ enigma2-PersianPrince/lib/dvb/frontend.cpp	2018-08-06 11:18:13.556061702 +0430
@@ -547,6 +547,9 @@
 	:m_simulate(simulate), m_enabled(false), m_fbc(false), m_simulate_fe(simulate_fe), m_type(-1), m_dvbid(fe), m_slotid(fe)
 	,m_fd(-1), m_dvbversion(0), m_rotor_mode(false), m_need_rotor_workaround(false), m_multitype(false)
 	,m_state(stateClosed), m_timeout(0), m_tuneTimer(0)
+#if HAVE_ALIEN5
+	,m_looptimeout(100)
+#endif
 {
 	m_filename = devicenodename;
 
@@ -805,6 +808,9 @@
 {
 	eDVBFrontend *sec_fe = this;
 	long tmp = m_data[LINKED_PREV_PTR];
+#if HAVE_ALIEN5
+	static int timeoutNum = 0;
+#endif
 	while (tmp != -1)
 	{
 		eDVBRegisteredFrontend *linked_fe = (eDVBRegisteredFrontend*)tmp;
@@ -816,6 +822,9 @@
 		dvb_frontend_event event;
 		int res;
 		int state;
+#if HAVE_ALIEN5
+		usleep(20000);
+#endif
 		res = ::ioctl(m_fd, FE_GET_EVENT, &event);
 
 		if (res && (errno == EAGAIN))
@@ -831,6 +840,25 @@
 		}
 		else
 		{
+#if HAVE_ALIEN5
+			if (m_tuning) {
+				state = stateTuning;
+				if (event.status & FE_TIMEDOUT) {
+					if (m_looptimeout == 0){
+						eDebug("[eDVBFrontend] FE_TIMEDOUT! ..abort");
+						m_tuneTimer->stop();
+						timeout();
+						return;
+					}
+					else{
+						m_looptimeout--;
+					}
+				
+				}
+				++m_tuning;
+				break;
+			}
+#else
 			if (m_tuning) {
 				state = stateTuning;
 				if (event.status & FE_TIMEDOUT) {
@@ -841,12 +869,17 @@
 				}
 				++m_tuning;
 			}
+#endif
 			else
 			{
 				eDebug("[eDVBFrontend] stateLostLock");
 				state = stateLostLock;
 				if (!m_rotor_mode)
 					sec_fe->m_data[CSW] = sec_fe->m_data[UCSW] = sec_fe->m_data[TONEBURST] = -1; // reset diseqc
+#if HAVE_ALIEN5
+				if(m_state == state)
+					break; /* I do not see any other way out */
+#endif
 			}
 		}
 		if (m_state != state)
@@ -1372,9 +1405,25 @@
 			fe_status_t status;
 			if (!m_simulate)
 			{
+#if HAVE_ALIEN5
+				usleep(20000);
+				if ( ioctl(m_fd, FE_READ_STATUS, &status) < 0 && errno != ERANGE )
+					eDebug("[eDVBFrontend] FE_READ_STATUS failed: %m");
+				if (status & FE_TIMEDOUT) {
+					if (m_looptimeout == 0){
+						ioctlMeasureEval("FE_READ_STATUS");
+						return (int)status;
+					}
+					else{
+						m_looptimeout--;
+					}
+				
+				}
+#else
 				if ( ioctl(m_fd, FE_READ_STATUS, &status) < 0 && errno != ERANGE )
 					eDebug("[eDVBFrontend] FE_READ_STATUS failed: %m");
 				return (int)status;
+#endif
 			}
 			return (FE_HAS_SYNC | FE_HAS_LOCK);
 		}
@@ -1771,6 +1820,36 @@
 					{
 						dvb_frontend_event event;
 						int res;
+#if HAVE_ALIEN5
+						usleep(20000);
+						if((res = ::ioctl(m_fd, FE_READ_STATUS, &event.status)) != 0)
+						{
+							break;
+						}
+						else
+						{
+							if(event.status == 0)
+							{
+								break;
+							}
+						}
+						if (event.status & FE_TIMEDOUT) {
+							if (m_looptimeout == 0){
+								eDebugNoSimulate("[eDVBFrontend] IF_LOCK_TIMEOUT_GOTO: got FE_TIMEDOUT");
+								setSecSequencePos(m_sec_sequence.current()->steps);
+								timeout = true;
+								break;
+							}
+							else{
+								m_looptimeout--;
+							}
+							break;
+						}
+						if (event.status & FE_HAS_LOCK)
+						{
+							break; /* I do not see any other way out */
+						}
+#else
 						res = ::ioctl(m_fd, FE_GET_EVENT, &event);
 
 						if (res && (errno == EAGAIN))
@@ -1783,6 +1862,7 @@
 							timeout = true;
 							break;
 						}
+#endif
 					}
 					if (timeout) break;
 				}
@@ -1975,6 +2055,9 @@
 		cmdseq.props = p;
 		cmdseq.num = 0;
 		p[cmdseq.num].cmd = DTV_CLEAR, cmdseq.num++;
+#if HAVE_ALIEN5
+		m_looptimeout = 100;
+#endif
 		if (type == iDVBFrontend::feSatellite)
 		{
 			eDVBFrontendParametersSatellite parm = {0};
@@ -1983,7 +2066,14 @@
 			fe_modulation_t modulation = QPSK;
 			fe_delivery_system_t system = SYS_DVBS;
 			oparm.getDVBS(parm);
-
+#if HAVE_ALIEN5
+			if (parm.symbol_rate < 5000000)
+		        m_looptimeout = 250;
+			else if (parm.symbol_rate < 10000000)
+		        m_looptimeout = 60;
+			else
+		        m_looptimeout = 50;
+#endif
 			switch (parm.system)
 			{
 				default:
@@ -2058,7 +2148,9 @@
 		{
 			eDVBFrontendParametersCable parm = {0};
 			oparm.getDVBC(parm);
-
+#if HAVE_ALIEN5
+			m_looptimeout = 300;
+#endif
 			p[cmdseq.num].cmd = DTV_DELIVERY_SYSTEM;
 #if DVB_API_VERSION > 5 || DVB_API_VERSION == 5 && DVB_API_VERSION_MINOR >= 6
 			if (m_dvbversion >= DVB_VERSION(5, 6))
@@ -2129,6 +2221,9 @@
 			eDVBFrontendParametersTerrestrial parm = {0};
 			fe_delivery_system_t system = SYS_DVBT;
 			oparm.getDVBT(parm);
+#if HAVE_ALIEN5
+			m_looptimeout = 100;
+#endif
 			switch (parm.system)
 			{
 				default:
diff -Naur enigma2-PLi/lib/dvb/frontend.h enigma2-PersianPrince/lib/dvb/frontend.h
--- enigma2-PLi/lib/dvb/frontend.h	2018-08-04 13:20:23.000000000 +0430
+++ enigma2-PersianPrince/lib/dvb/frontend.h	2018-08-06 11:19:08.566915635 +0430
@@ -80,6 +80,9 @@
 	bool m_fbc;
 	eDVBFrontend *m_simulate_fe; // only used to set frontend type in dvb.cpp
 	int m_type;
+#if HAVE_ALIEN5
+	int m_looptimeout;
+#endif
 	int m_dvbid;
 	int m_slotid;
 	int m_fd;
diff -Naur enigma2-PLi/lib/service/servicedvb.cpp enigma2-PersianPrince/lib/service/servicedvb.cpp
--- enigma2-PLi/lib/service/servicedvb.cpp	2018-08-04 13:20:23.000000000 +0430
+++ enigma2-PersianPrince/lib/service/servicedvb.cpp	2018-08-06 11:21:50.747663051 +0430
@@ -38,6 +38,12 @@
 #include <sstream>
 #include <iomanip>
 
+#if HAVE_ALIEN5
+extern "C" {
+#include <codec.h>
+}
+#endif
+
 class eStaticServiceDVBInformation: public iStaticServiceInformation
 {
 	DECLARE_REF(eStaticServiceDVBInformation);
@@ -1368,6 +1374,14 @@
 		type = eDVBServicePMTHandler::streamclient;
 	}
 
+#if HAVE_ALIEN5
+	if(m_is_stream || m_is_pvr)
+	{
+			eDebug("[eDVBServicePlay] start m_is_pvr %d", m_is_pvr);
+			aml_set_demux2_source();
+	}
+#endif
+
 	m_first_program_info = 1;
 	ePtr<iTsSource> source = createTsSource(service, packetsize);
 	m_service_handler.tuneExt(service, source, service.path.c_str(), m_cue, false, m_dvb_service, type, scrambled);
